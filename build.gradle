plugins {
    id 'java-library'
    id 'maven-publish'
    id "de.undercouch.download" version "4.1.1"
}

group = 'wasmtime'
version = '0.1.0'

repositories {
    jcenter()
}

dependencies {
    compileOnly 'org.projectlombok:lombok:1.18.12'
    annotationProcessor 'org.projectlombok:lombok:1.18.12'
    implementation 'org.slf4j:slf4j-api:1.7.25'

    testImplementation 'junit:junit:4.13'
}

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

compileJava {
    options.compilerArgs << '-parameters'
}

static def jniLibOsClassifier() {
    def os = System.getProperty("os.name").toLowerCase()
    if (os.contains("linux")) {
        return "linux"
    }
    if (os.contains("mac os") || os.contains("darwin")) {
        return "macos"
    }
    throw new RuntimeException("platform not supported: " + System.getProperty("os.name"))
}

processResources {
    dependsOn 'metaProperties', 'copyJniLib'
    from(new File(project.buildDir, "tmp")) {
        include 'wasmtime-java-meta.properties'
    }
    from(new File(project.buildDir, "jni-libs")) {
        include "libwasmtime_jni_${project.version}_${jniLibOsClassifier()}.*"
    }
}

task metaProperties() {
    doLast {
        def props = new Properties()
        props.setProperty("jnilib.version", "${project.version}")
        props.store(new File(project.buildDir, "tmp/wasmtime-java-meta.properties").newOutputStream(), null)
    }
}

def javah4xVersion = '0.1.0'
task downloadJavah4x(type: Download) {
    src "https://github.com/kawamuray/javah4x/releases/download/v${javah4xVersion}/javah4x-bin-${javah4xVersion}.zip"
    dest new File(project.buildDir, "tmp")
    overwrite false
}

task unzipJavah4x(type: Copy) {
    dependsOn 'downloadJavah4x'
    from zipTree(new File(project.buildDir, "tmp/javah4x-bin-${javah4xVersion}.zip"))
    into new File(project.buildDir, "tmp")
}

task generateJniInterfaces(type:Exec) {
    def targets = [
            'wasmtime.Engine',
            'wasmtime.Func',
            'wasmtime.Instance',
            'wasmtime.Linker',
            'wasmtime.Memory',
            'wasmtime.Module',
            'wasmtime.Store',
            'wasmtime.wasi.Wasi']
    dependsOn 'unzipJavah4x', 'compileJava'
    environment 'CLASSPATH', sourceSets.main.runtimeClasspath.collect { it.path }.join(':')
    // JNI shared object isn't available at this stage
    environment 'WASMTIME_JNI_LOAD_DISABLED', '1'
    commandLine(["${project.buildDir}/tmp/javah4x-${javah4xVersion}", 'rust', './wasmtime-jni/src'] + targets)
    // Manually compare the source (class files) and output (rust sources) to run this task only when any
    // update is made on classes.
    outputs.upToDateWhen {
        def smallestGeneratedTimestamp = targets.collect {
            new File(project.rootDir, "wasmtime-jni/src/${it.replace(".", "_")}/mod.rs").lastModified()
        }.min()
        def largestSourceTimestamp = targets.collect {
            def path = "classes/java/main/" + it.replace(".", "/") + ".class"
            new File(project.buildDir, path).lastModified()
        }.max()
        smallestGeneratedTimestamp >= largestSourceTimestamp
    }
}

task buildJniLib(type:Exec) {
    dependsOn 'generateJniInterfaces'
    workingDir './wasmtime-jni'
    commandLine 'cargo', 'build', '--release'
}

task copyJniLib(type: Copy) {
    dependsOn 'buildJniLib'
    from "wasmtime-jni/target/release"
    include '*.so', '*.dylib'
    rename "^libwasmtime_jni", "libwasmtime_jni_${project.version}_${jniLibOsClassifier()}"
    into new File(project.buildDir, "jni-libs")
}

task universalJar(type: Jar) {
    dependsOn 'jar'
    archiveClassifier.set("universal")
    from zipTree(jar.outputs.files.singleFile)
    from new File(project.rootDir, "jni-libs")
}

publishing {
    publications {
        maven(MavenPublication) {
            from components.java
        }
    }
}
